Constructor is a special method given in OOP language for creating and initializing object.  In java , constructor role is only initializing object , and new keyword role is crating object.

* Name of the constructor must be same as that of a class name. If you give another name it will give compile time error. If you give another name, it is neither a method because of no return type, nor constructor because name is different from class name.

	class A
	{
		 A()
		 {
			 // Constructor of Class A
		 }
		 A1()
		 {
			 // Compile time error, It is neither a constructor nor a method
		 }
	}

* Constructors must not have a return type. If you keep return type for the constructor, it will be treated as another method.But compiler gives a warning saying that this method has a constructor name. That means, it is legal to have method name same as constructor name or same as class name but it is not recommended.

	class A
	{
		 A()
		 {
			 // Constructor of Class A, not having any return type.
		 }
	 
		 void A()
		 {
			 // constructor having a return type, It will be treated as method but with a warning.
		 }
	} 
	
* Every class should have at least one constructor. If you don’t write constructor for your class, compiler will give default constructor. Default constructor is always public and it has no arguments (No-Arg Constructor).

* Constructor can be declared as private. If you declare constructor as private, you can’t use it outside that class.

	class A
	{
		 private A()
		 {
			  // Private Constructor
		 }
	 
		 void methodOne()
		 {
			  //You can use private constructor inside the class
			  A a1 = new A();
		 }
	}
	 
	class MainClass
	{
		 public static void main(String[] args)
		 {
			  //You can't use private constructor ouside the class like this
			  // A a1 = new A();
		 }
	}
	
* One class can have more than one constructors. It is called Constructor Overloading. Through constructor overloading, you can have multiple ways to create objects.

* Duplicate Constructors not allowed. If you keep duplicate constructors, you will get compile time error.

* Only public, protected and private keywords are allowed before a constructor name. If you keep any other keyword before a constructor name, it gives compile time error.

	class A
	{
		 final A()
		 {
			 //Constructor can not be final
		 }
		 static A()
		 {
			 //Constructor can not be static
		 }
		 abstract A()
		 {
			//Constructors can not be abstract
		 }
	} 
	
* First statement in a constructor must be either super() or this(). If you put any other statements you will get compile time error.If you don’t include these statements, by default compiler will keep super() calling statement. super() – It is a calling statement to default constructor of super class. this()- it is a calling statement to constructor of the same class.

	class A
	{
		 A()
		 {
			  //By Default, Compile will keep super() calling statement here.
			  System.out.println("First Constructor");
		 }
		 A(int i)
		 {
			  //Compiler will not keep any statement here
			  super();
			  System.out.println("Second Constructor");
		 }
		 A(int i, int j)
		 {
			  //Compiler will not keep any statement here
			  this();
			  System.out.println("Third Constructor");
		 }
		 A(int i, int j, int k)
		 {
			  System.out.println("Fourth Constructor");
			  // super(); It will give error if you keep super() here
		 }
	}
	
* Recursive constructor calling is not allowed.

	class A
	{
		 A()
		 {
			  this();
			  // It gives compile time error
		 }
	}
	
* No Cylic calling of constructors.

	class A
	{
		 A()
		 {
			  this(10);
			  // It gives compile time error
		 }
		 A(int i)
		 {
			  this();
			  // It gives compile time error
		 }
	}
	
--------------------------------------------------------------------

Question : Why return type is not allowed for constructor?

Answer : As there is a possibility to define a method with same class name , return type is not allowed to constructor to differentiate constructor block from method block.

What actually happens with the constructor is that the runtime uses type data generated by the compiler to determine how much space is needed to store an object instance in memory, be it on the stack or on the heap.

This space includes all members variables and the vtbl. After this space is allocated, the constructor is called as an internal part of the instantiation and initialization process to initialize the contents of the fields.

Then, when the constructor exits, the runtime returns the newly-created instance. So the reason the constructor doesn't return a value is because it's not called directly by your code, it's called by the memory allocation and object initialization code in the runtime.

Its return value (if it actually has one when compiled down to machine code) is opaque to the user - therefore, you can't specify it.

------------------------------

Question : How compiler and JVM can differentiate constructor and method invocations of both have same class name?

Answer : By using new keyword, if new keyword is used in calling then constructor is executed else method is executed.

-------------------------------

Question : Can we use this() and super() in a method?
Answer : No, We can’t use this() and super() in a method.

------------------------------
Question : What is constructor chaining?

Answer : Constructor Chaining is a technique of calling another constructor from one constructor. this() is used to call same class constructor where as super() is used to call super class constructor. 

-------------------------------

Question : Does Constructor creates the object ?

Answer : New operator in Java creates objects. Constructor is the later step in object creation. Constructor's job is to initialize the members after the object has reserved memory for itself.

--------------------------------

Question : Do we have destructors in Java?

Answer : No, Because Java is a garbage collected language you cannot predict when (or even if) an object will be destroyed. Hence there is no direct equivalent of a destructor.
--------------------------------

COPY CONSTRUCTOR IN JAVA :

Like C++, Java also supports copy constructor. But, unlike C++, Java doesn’t create a default copy constructor if you don’t write your own.

	class Complex {
	 
		private double re, im;
		 
		// A normal parametrized constructor 
		public Complex(double re, double im) {
			this.re = re;
			this.im = im;
		}
		 
		// copy constructor
		Complex(Complex c) {
			System.out.println("Copy constructor called");
			re = c.re;
			im = c.im;
		}
		  
		// Overriding the toString of Object class
		@Override
		public String toString() {
			return "(" + re + " + " + im + "i)";
		}
	}
	 
	public class Main {
	 
		public static void main(String[] args) {
			Complex c1 = new Complex(10, 15);
			 
			// Following involves a copy constructor call
			Complex c2 = new Complex(c1);   
	 
			// Note that following doesn't involve a copy constructor call as 
			// non-primitive variables are just references.
			Complex c3 = c2;   
	 
			System.out.println(c2); // toString() of c2 is called here
		}
	}

------------------------------------------

HOW TO CREATE AN OBJECT WITHOUT USING NEW OPERATOR :

Yes, We can create an object without using new operator.

a) Using newInstance() Method


	Class c = Class.forName("packageName.MyClass");
	MyClass object = (MyClass) c.newInstance();

b) Using clone() method.

	MyClass object1 = new MyClass();
	MyClass object2 = object1.clone();		
	
c) Using object deserialization

	ObjectInputStream inStream = new ObjectInputStream(anInputStream );
	MyClass object = (MyClass) inStream.readObject();

d) Creating string and array objects :

	String s = "string object";
	int[] a = {1, 2, 3, 4};
----------------------------------------